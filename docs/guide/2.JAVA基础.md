# 2.Java基础篇
## 语法篇
### JDK、JRE和JVM的关系
JDK、JRE和JVM的关系：



- JDK(Java Development Kit)是Java开发工具包的缩写，包含了Java编译器、Java运行时环境(JRE)和其他开发工具。JDK是开发Java应用程序的必备工具，它提供了编写、编译、调试和运行Java程序所需的所有组件。
- JRE(Java Runtime Environment)是Java运行时环境的缩写，包含了Java虚拟机(JVM)和Java类库。JRE提供了Java程序运行的环境，包括了Java虚拟机和Java类库，可以让Java程序在任何支持Java虚拟机的操作系统上运行。
- JVM(Java Virtual Machine)是Java虚拟机的缩写，是Java程序执行的核心组件。JVM是一个虚拟计算机，它可以在任何支持Java虚拟机的操作系统上执行Java程序。JVM负责将Java源代码编译成字节码，并在运行时解释执行字节码。

因此，可以简单地将JDK看作是开发工具包，JRE看作是Java程序运行的环境，而JVM则是Java程序执行的核心组件。在实际使用中，通常需要安装JDK来开发Java应用程序，然后通过命令行或集成开发环境(IDE)来运行JRE来测试和调试Java程序，最终通过JVM来执行Java程序。
![](assets/image-20230525170831628.png#id=n4nca&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
### 栈和堆分别存的什么数据
栈和堆是计算机内存中的两种数据结构，它们分别用于存储不同类型的数据。

1. 栈(Stack)：栈是一种**后进先出**(LIFO)的数据结构，也就是说最后进入栈的数据会最先被弹出。栈通常用于存储函数调用时的参数、局部变量、返回地址等数据。在Java中，基本类型数据(如int、float、char等)和对象引用都属于栈上数据，而数组元素也是栈上数据。
2. 堆(Heap)：堆是一种**先进先出**(FIFO)的数据结构，也就是说最先进入堆的数据会最先被弹出。堆通常用于存储动态分配的内存，比如Java中的new操作符创建的对象、数组等。在Java中，对象实例和数组元素都属于堆上数据。

> 补充：**堆是一种树形数据结构，它可以动态地分配和回收内存，支持高效的插入、删除和排序等操作。**
> 需要注意的是，Java中的垃圾回收机制会自动管理堆上的内存分配和释放，程序员不需要手动进行内存管理。

![](assets/image-20230601173438694.png#id=TkJMT&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
### 异步和同步
异步调用和同步调用都是指程序中不同组件之间的调用方式。
  在同步调用中，**程序的某个组件会在调用另一个组件时等待该组件完成后，才会继续执行下一步操作。**也就是说，在同步调用过程中，程序的运行会阻塞等待被调用组件的响应结果。
  而在异步调用中，**程序的调用不会等待被调用组件返回结果，而是继续执行下一步操作**。被调用组件会通过回调函数或事件通知的方式返回结果，程序在收到结果后再对其进行处理。也就是说，在异步调用过程中，程序的运行不会被阻塞，可以同时执行多个调用操作。
  异步调用通常用于网络请求、GUI编程和其他需要同时处理多个任务的场景中，而同步调用通常用于需要依次处理任务的场景中。

### 线程和进程区别
![](assets/58369465841a4cdea8083b6951dff710.png#id=W8vEg&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
线程和进程是操作系统中用于实现多任务处理的两个基本概念，它们有以下区别：

1. 资源占用：一个进程可以独立占用系统资源，如内存、CPU等；而一个线程只能占用一定的系统资源，如栈空间、寄存器等。
2. 调度：进程是操作系统中的独立实体，它可以被操作系统分配资源和调度执行；而线程是在进程内部的执行单元，它的调度由进程管理。
3. 通信：由于进程之间是相互独立的，它们之间的通信需要通过进程间通信(IPC)机制来实现；而线程之间共享同一个进程的内存空间，因此可以直接进行通信。
4. 数据保护：由于每个进程都有自己独立的内存空间，因此不同进程之间的数据是相互隔离的；而线程共享同一个进程的内存空间，因此需要注意数据保护的问题。

总之，线程和进程都是实现多任务处理的基本概念，它们各自具有不同的特点和优缺点，在实际应用中需要根据具体的需求选择合适的方式。
补充：**一个进程可以包含多个线程，这些线程共享同一个进程的内存空间和系统资源。**在Java中，一个进程可以包含多个线程，这些线程可以通过继承Thread类或实现Runnable接口来创建。
### java的数据类型有哪些
| 类型 | 占用字节 | 取值范围 | 包装类 | 默认值 |
| --- | --- | --- | --- | --- |
| byte(字节型) | 1 | -128～127（-2的7次方到2的7次方-1） | Byte | 0 |
| short（短整型） | 2 | -32768～32767（-2的15次方到2的15次方-1） | Short | 0 |
| int（整型） | 4 | -2147483648～2147483647（-2的31次方到2的31次方-1） | Integer | 0 |
| long（长整型） | 8 | -9223372036854774808～9223372036854774807（-2的63次方到2的63次方-1） | Long | 0L |
| float（浮点型） | 4 | 3.402823e+38～1.401298e-45（e+38 表示乘以10的38次方，而e-45 表示乘以10的负45次方 | Float | 0.0f |
| double（双精度浮点型） | 8 | 1.797693e+308～4.9000000e-324（e+38 表示乘以10的38次方，而e-45 表示乘以10的负45次方 | Double | 0.0d |
| boolean（布尔型） | 2 | true false | Boolean | false |
| char（字符型） | 1 | 汉字字母都可以 | Character | \\u0000 |

### equals和HashCode重写的问题?
  在Java中，Object类中提供了equals()和hashCode()方法用于**比较对象是否相等以及生成对象的哈希码**。默认情况下，equals()方法会比较对象的内存地址，而hashCode()方法则会根据对象的属性值计算出一个整数值作为哈希码。
  重写equals方法后，即使两个对象的属性值完全相同，它们也被认为是相等的。这是因为equals方法比较的是对象是否相等，而不是对象的哈希码是否相等。
  因此，如果我们不重写hashCode方法，那么即使两个对象相等，它们的哈希码也可能不同。这会导致在使用哈希表等数据结构时出现意外的结果。
  另外，如果多个对象具有相同的属性值，那么它们可能会被认为相等，从而出现在哈希表中出现多次的情况。这会影响哈希表的性能和正确性。
  因此，为了保证对象在哈希表中的正确性和性能，我们需要重写hashCode方法，确保每个对象都有唯一的哈希码。通常的做法是将每个属性的值取反后再进行求和，这样可以避免哈希冲突的问题。
> 一般情况下，我们保证，当两个对象的Hashcode相同的时候对象不一定相同，但是当两个对象的equals方法相同时，这两个对象一定相同。
> **举例：**如果我们有1000万个对象，这个时候要找出外界输入的对象，判断和我们1000万个对象中哪个对象相等，这个时候我们会先调用hashcode方法，去大大的缩小范围，然后再使用equals方法，这样就可以大大提高我们寻找对象的速度。

### 深拷贝和浅拷贝的区别
**浅拷贝：**浅拷贝是指只复制对象本身的值，不复制它所引用的对象，因此新旧对象共享同一个引用对象。在 Java 中，可以通过实现 Cloneable 接口和覆盖 `clone()` 方法来实现浅拷贝。
**深拷贝：**深拷贝是指复制对象本身和所有它所引用的对象，因此新旧对象不共享任何引用对象。在 Java 中，可以通过实现 Serializable 接口和使用序列化/反序列化来实现深拷贝。例如：
### ==和equals的区别

- == 既可以比较基本类型也可以比较引用类型，对于基本类型就是比较值，对于引用类型及时比较内存的地址
- equals的话，他是属于java.lang.Object类里面的方法，如果该方法没有被重写过，默认也是== ，我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equasl是比较值的错误观点.
- 具体要看自定义类里面有没有重写Object的equals方法来判断
- 通常情况下，重写equals方法，会比较类中的属性是否相等
```java
/**
 * ==和equals的区别
 */
public class Test_01 {
    public static void main(String[] args) {

        /**
         * 比较基本数据类型
         */
        int a=1;
        double b=1.0;
        char c=1;
        System.out.println(a==b);  //true
        System.out.println(a==c);  //true


        /**
         * 引用数据类型
         */
        Customer c1 = new Customer("小明", 20);
        Customer c2 = new Customer("小明", 20);
        System.out.println(c1 == c2);       //false
        System.out.println(c1.equals(c2));  //false


//      String
        String str1 = new String("sth");
        String str2 = new String("sth");
        System.out.println(str1 == str2);      // false
        System.out.println(str1.equals(str2)); // true


//      java中String new和直接赋值的区别
//      对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，
//      如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。
        String s1="123"; //在常量池中
        String s2="123";
        System.out.println(s1==s2);  //true
        String s3 = new String("123");  //存储在堆内存中
        System.out.println(s1==s3);
        
        /**
         * Integer
         */
        Integer i1=1;
        Integer i2=1;
        System.out.println(i1==i2); //true

        Integer i3=128;
        Integer i4=128;
        System.out.println(i3==i4); //false
        System.out.println(i3.equals(i4));
    }
}
class Customer {
    private String namg;
    private int age;

    public Customer(){

    }

    public Customer(String namg, int age) {
        this.namg = namg;
        this.age = age;
    }

    public String getNamg() {
        return namg;
    }

    public void setNamg(String namg) {
        this.namg = namg;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```
### 常见的运行时异常有哪些？
ArithmeticException(算术异常)
ClassCastException(类转换异常)
IllegalArgumentException(非法参数异常)
IndexOutOfBoundsException(下标越界异常)
NullPointerException(空指针异常)
SecurityException(安全异常)

## 面向对象
### 重载和重写的区别★★★
  重载(Overloading)和重写(Overriding)都是Java中面向对象编程的特性，它们都可以让子类继承父类的方法。但是它们之间有一些重要的区别：

- 定义方式：
   - 重载(Overloading)：**在同一个类中**，可以有**多个方法名相同但参数列表不同的方法**。当调用一个方法时，编译器会根据参数的数量、类型和顺序来判断调用哪个方法。
   - 重写(Overriding)：在子类中，必须定义与父类同名、参数类型和返回值类型相同的方法。这样才能覆盖掉父类中的方法，使得子类对象调用该方法时执行的是子类自己的代码。
- 访问权限：
   - 重载(Overloading)：**方法名相同但参数列表不同**，因此它们的访问权限是一样的，都是public、protected或private。
   - 重写(Overriding)：子类中的方法必须使用super关键字来调用父类的方法，这意味着**子类中的方法具有比父类中相同的方法更低的访问权限**。

总之，重载和重写都是Java中多态性的重要特性，但它们的作用和实现方式有所不同。重载允许在同一类中定义多个同名但参数不同的方法，而重写允许子类覆盖父类的方法并提供自己的实现。


### Java的三大特性
Java的三大特性是：

1. **面向对象编程**(Object-Oriented Programming,OOP)：Java是一种纯面向对象的编程语言，它支持封装、继承和多态等面向对象的特性。通过封装，Java可以将数据和方法封装在一起，形成一个类，从而实现对数据的保护；通过继承，Java可以从已有的类中继承属性和方法，避免重复编写代码；通过多态，Java可以让不同的对象对同一个消息做出不同的响应，提高了代码的复用性和灵活性。
2. **平台无关性**(Platform Independence)：Java程序可以在不同的操作系统上运行，这是因为Java编译器将Java源代码编译成字节码(bytecode),然后由Java虚拟机(JVM)将字节码解释执行。因此，无论在哪个平台上安装了Java虚拟机，都可以运行Java程序。这种平台无关性使得Java成为一种非常适合开发跨平台应用程序的语言。
3. **安全性**(Security)：Java提供了多种安全机制来保护应用程序的安全，包括沙箱安全模型、类加载器、安全管理器等。这些机制可以限制应用程序的访问权限，防止恶意代码的执行，保证了应用程序的安全性和稳定性。同时，Java还提供了加密和数字签名等标准安全协议，使得Java应用程序可以方便地与其他系统进行安全通信。
### 请说明一下Super关键字的作用？
在Java类中使用super来调用父类中的指定操作

- super可以用来访问父类中定义的属性
- super可以用于调用父类中定义的成员方法
- super可以同于子类构造器中调用父类的构造器
### static关键字的作用？
在Java中，static关键字有以下几种作用：
**1.修饰类成员变量和方法：**

- 修饰类成员变量：被static修饰的成员变量是静态变量，**它们属于类而不是对象**。静态变量可以在类的任何地方访问，且只有一份实例。例如：
- public static int count = 0;。
- 修饰类成员方法：被static修饰的方法是静态方法，它们不依赖于对象而是直接通过类名调用。静态方法可以在类的任何地方调用，且没有this指针。例如：public static void printCount() { System.out.println(count); }。

**2.修饰局部变量：**

- 被static修饰的局部变量成为静态局部变量，它们属于类而不是对象。静态局部变量只能在类的静态方法中初始化一次。例如：public static void test() { static int count = 0; count++; System.out.println("count=" + count); }。

3.表示类和接口的常量：

- 被static修饰的常量是类和接口的常量，它们在整个程序中都是可见的。例如：public static final int MAX_COUNT = 100;。

   1. 表示线程安全：
- 被static修饰的方法可以保证多线程访问时的安全性。例如：public static synchronized void printCount() { System.out.println(count); }。

总之，static关键字可以用来修饰类、方法、局部变量、常量和线程安全等方面，具有不同的作用和意义。
### final关键字的作用？
在Java中，final关键字有以下几种作用：

1. 修饰类和方法：
   - 修饰类：被final修饰的`类不能被继承`。例如：final class MyClass。
   - 修饰方法：被final修饰的方法不能被子类`重写`。例如：final void myMethod() {}。
2. 修饰变量：
   - 修饰全局变量：被final修饰的全局变量只能在声明时赋值一次。例如：final int MAX_VALUE = 100;。
   - 修饰局部变量：被final修饰的局部变量只能在定义时初始化一次。例如：final int x = 5;。
3. 表示常量：
   - final修饰的常量是不可修改的，一旦赋值就不能再改变。例如：final int MAX_VALUE = 100;。
4. 表示线程安全：
   - final修饰的实例方法可以保证多线程访问时的安全性。例如：final class MyClass { ... }。

总之，final关键字可以用来修饰类、方法、变量和线程安全等方面，具有不同的作用和意义。

### super关键字和this关键字的作用？
![](assets/image-20230604134325083.png#id=cFbB3&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
### 面向对象的三大特性★★★
面向对象编程的三大特性是封装、继承和多态。

1. 封装(Encapsulation)：封装是指将**数据和方法捆绑在一起**，形成一个类，对外部隐藏实现细节，只提供必要的接口给外部使用。通过封装，可以保护数据的安全性和完整性，防止外部程序直接访问和修改数据，从而提高程序的可维护性和稳定性。
2. 继承(Inheritance)：继承是指**子类可以从父类中继承属性和方法**，避免重复编写代码。通过继承，可以提高代码的复用性和灵活性，使得程序更加模块化和可扩展。但是需要注意的是，过度的继承会导致代码变得复杂和难以维护。
3. 多态(Polymorphism)：多态是指同**一个方法可以根据不同的参数类型和数量表现出不同的行为**。通过多态，可以提高代码的灵活性和可扩展性，使得程序更加通用和易于维护。Java中的多态主要有两种形式：方法重载(Method Overloading)和方法重写(Method Overriding)。
### 成员变量和局部变量的区别？
![](assets/image-20230604134435944.png#id=TOXSF&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)

### Java能实现多继承么
  Java不支持多继承，它只支持单继承。这意味着**一个类只能继承自一个直接父类**，而不能同时继承多个父类。
  在Java中，一个类可以实现多个接口。
### 抽象类(abstract class) 与接口(interface)的区别？★★★
抽象类和接口都是用来定义类或类的成员的，但它们之间有以下区别：

1. 实现方式不同：抽象类必须被子类实现，而接口可以被多个类实现。
2. 抽象方法和默认方法不同：抽象类中可以定义抽象方法和非抽象方法，而接口只能定义抽象方法。
3. 构造函数不同：抽象类可以定义构造函数，而接口不能定义构造函数。
4. final修饰符的使用不同：抽象类中可以定义final修饰符，而接口中的所有方法都不能被final修饰。
5. 继承限制不同：子类只能继承一个抽象类，而一个类可以实现多个接口。

总之，抽象类更像是一种“半成品”，它提供了一些基本的实现，但还需要子类去完善；而接口则更像是一种规范，它规定了一组方法和常量，但并不提供具体的实现。
![](assets/image-20230604133323757.png#id=u8O3a&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
### 能详细解释一下封装么？
**将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法**

1. 封装可以被认为是一个保**护屏障，**防止该类的代码和数据被外部类定义的代码随机访问。
2. 要访问该类的代码和数据，必须通过严格的接口控制。
3. 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。
4. 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。

程序涉及追求——>**高内聚，低耦合**
**高内聚：类的内部数组操作细节自己完成，不允许外部干涉。**
**低耦合：仅对外暴露少量的方法用于使用。**
**关于四种权限修饰符的说明：**
![](assets/image-20230604133912521.png#id=ygjuM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
### 继承你了解哪些？
Java中继承是一种面向对象编程的基本概念，它允许一个类(子类)从另一个类(父类)中继承属性和方法。以下是Java中继承的一些基本知识：

1. 继承的语法：在Java中，使用extends关键字来声明一个类继承另一个类。例如：
```java

class Animal {
  // 父类中的属性和方法
}

class Dog extends Animal {
  // 子类中的额外属性和方法
}


```

2. 子类可以重写父类的方法：子类可以覆盖(override)父类中定义的方法，以实现自己的行为。例如：
```java

class Animal {
  public void eat() {
    System.out.println("Animal is eating");
  }
}

class Dog extends Animal {
  @Override
  public void eat() {
    System.out.println("Dog is eating");
  }
}

public class Main {
  public static void main(String[] args) {
    Dog dog = new Dog();
    dog.eat(); //输出 "Dog is eating"
  }
}


```

3. 子类可以访问父类中的公有、受保护和默认(package-private)成员：子类可以访问其继承的父类中的公有、受保护和默认(package-private)成员。例如：
```java

class Animal {
  public int age;
}

class Dog extends Animal {
  public void bark() {
    System.out.println("Woof! My age is " + age);
  }
}

public class Main {
  public static void main(String[] args) {
    Dog dog = new Dog();
    dog.age = 3; //可以修改子类的属性age,但不能修改父类的属性age
    dog.bark(); //输出 "Woof! My age is 3"
  }
}


```
### 多态你了解哪些？
**多态是同一个行为具有多个不同表现形式或形态的能力。**
多态一般分为两种：重写式多态和重载式多态。
**重载式多态**，也叫编译时多态。也就是说这种多态再编译时已经确定好了。重载大家都知道，方法名相同而参数列表不同的一组方法就是重载。在调用这种重载的方法时，通过传入不同的参数最后得到不同的结果。
> 但是这里是有歧义的，有的人觉得不应该把重载也算作多态。因为很多人对多态的理解是：程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，这种情况叫做多态。 这个定义中描述的就是我们的第二种多态—重写式多态。

**重写式多态**，也叫运行时多态。这种多态通过动态绑定（dynamic binding）技术来实现，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。也就是说，只有程序运行起来，你才知道调用的是哪个子类的方法。 这种多态通过函数的重写以及向上转型来实现，我们上面代码中的例子就是一个完整的重写式多态。我们接下来讲的所有多态都是重写式多态，因为它才是面向对象编程中真正的多态。
 总而言之我的理解：重载式多态，在编码等过程中，并没有很好的体现出多态的优势，但是不得否认也是多态的一种编写方式，而给出的重写式多态案例中，相比于重载式多态，在编码思路和代码量以及聚合度方面都较好的体现出了多态的优势。
**多态的优点**

- 消除类型之间的耦合关系
- 可替换性
- 可扩充性
- 接口性
- 灵活性
- 简化性

**多态存在的三个必要条件**

- 继承
- 重写
- 父类引用指向子类对象
```java
public class Test {
    public static void main(String[] args) {
        show(new Cat());  // 以 Cat 对象调用 show 方法
        show(new Dog());  // 以 Dog 对象调用 show 方法
        /**
         * 上面两行可以发现，show方法要求传入的是动物对象，因为猫和狗都继承了动物类，因此符合规范，
         *         同时体现出多态的优势：一个形参可以对应多个实参，同时这也是一个重写式多态
         */


        Animal a = new Cat();  // 向上转型：通过子类实例化父类
        a.eat();               // 调用的是 Cat 的 eat
        //a.work();如果运行这一行就会发现，无法调用work方法，因为动物类只有eat一个方法，从而cat失去了特有方法

        Cat c = (Cat)a;        // 向下转型：通过父类强制转化为子类
        c.work();        // 调用的是 Cat 的 work
        /**
         * 上面两行体现了向下转型的用处，我们可以知道，对象a目前是一个动物对象，不能执行猫或者狗的特有方法
         * 但是，如果通过向下转型，将动物a对象，转化为一个猫c对象，这样就可以调用猫的特有方法了
         */


        /**
         * 得出结论：
         * 向上转型 : 通过子类对象(小范围)实例化父类对象(大范围),这种属于自动转换
         * 向下转型 : 通过父类对象(大范围)实例化子类对象(小范围),这种属于强制转换
         */

    }

    public static void show(Animal a)  {
        a.eat();
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情
            Cat c = (Cat)a;
            c.work();
        } else if (a instanceof Dog) { // 狗做的事情
            Dog c = (Dog)a;
            c.work();
        }
    }
}

//定义一个抽象类
abstract class Animal {
    abstract void eat();
}

//下面的每一个类继承抽象类，重写接口中的方法
class Cat extends Animal {
    public void eat() {
        System.out.println("吃鱼");
    }
    public void work() {
        System.out.println("抓老鼠");
    }
}

class Dog extends Animal {
    public void eat() {
        System.out.println("吃骨头");
    }
    public void work() {
        System.out.println("看家");
    }
}
```
## IO流
==关于javaIO流部分参考链接：==[https://blog.csdn.net/qq_44715943/article/details/116501936](https://blog.csdn.net/qq_44715943/article/details/116501936)
### Bit,Byte,Char之间的区别？
Bit最小的二进制单位 ，是计算机的操作部分取值0或者1。
Byte是计算机中存储数据的单元，是一个8位的二进制数，（计算机内部，一个字节可表示一个英文字母，两个字节可表示一个汉字。） 取值（-128-127）
Char是用户的可读写的最小单位，他只是抽象意义上的一个符号。如‘5’，‘中’，‘￥’等等。在java里面由16位bit组成Char 取值（0-65535）
Bit 是最小单位 计算机他只能认识0或者1
Byte是8个字节 是给计算机看的
字符 是看到的东西 一个字符=二个字节
### Java中有几种类型的流？
**按照流的方向**：输入流(inputStream)和输出流(outputStream)
**按照实现功能分**：节点流（可以从或向一个特定的地方（节点）读写数据。如FileReader)和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。)
**按照处理数据的单位**：字节流和字符流。字节流继承于InputStream和OutputStream,字符流继承于InputStreamReader和OutputStreamWriter.

### 字节流和字符流的区别★★★
		**字节流和字符流是 Java IO 中两种基本的输入输出流类型。**
  字节流(Byte Stream)用于处理二进制数据，如图像、音频、视频等。它以字节为单位读取和写入数据，可以处理任何类型的数据，包括文本、二进制文件等。Java 提供了 FileInputStream、ByteArrayInputStream、BufferedInputStream 等字节流类。
  字符流(Character Stream)用于处理文本数据，如文本文件等。它以字符为单位读取和写入数据，只能处理 ASCII 码表中的字符。Java 提供了 FileReader、BufferedReader、ReaderWriter 等字符流类。
  在实际应用中，我们通常需要同时使用字节流和字符流来处理不同类型的数据。例如，在使用网络协议进行通信时，我们需要使用字节流来传输数据；而在使用文本文件进行读写操作时，则需要使用字符流。
![](assets/image-20230604130936471.png#id=tC30h&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
### String， StringBuffer，StringBuilder的区别？★★★
		String、StringBuffer 和 StringBuilder 都是 Java 中用于处理字符串的类，它们的区别如下：

1. String 是一个不可变对象，一旦被创建就无法被改变。对 String 进行修改操作时，会创建一个新的 String 对象。因此在频繁修改字符串时，创建大量的 String 对象会导致内存浪费。
2. StringBuffer 是可变对象，可以进行字符串修改操作而不是创建新的对象。对 StringBuffer 进行修改操作时，不会创建新的字符串对象，而是直接修改原有的对象。因此，使用 StringBuffer 可以提高程序的性能。
3. StringBuilder 也是可变对象，它提供了与 StringBuffer 相同的功能，但是相对于 StringBuffer 来说，StringBuilder 在执行效率上更高，因为它不需要创建新的字符串对象。

在使用上，一般情况下应该优先考虑使用 StringBuilder,只有在需要返回一个可变字符串时才使用 StringBuffer。如果只需要对字符串进行简单的修改操作，则可以使用 String 类型。

### 对数据流的了解，JavaIO部分?
Java IO(Input/Output)是Java编程语言中用于读写数据的模块。它提供了一组类和接口，可以方便地进行文件读写、网络通信等操作。其中，数据流(Data Stream)是Java IO的一个重要概念。
Java IO中的数据流可以分为**字节流和字符流**两种类型。字节流适用于处理二进制数据，如图片、音频、视频等；字符流适用于处理文本数据，如文件内容、网络传输等。
在Java IO中，常用的数据流类有：

- FileInputStream：从文件中读取字节流
- FileOutputStream：向文件中写入字节流
- DataInputStream：从文件或网络连接中读取字节流
- DataOutputStream：从文件或网络连接中写入字节流
- BufferedInputStream：带有缓存的字节流输入流
- BufferedOutputStream：带有缓存的字节流输出流

除了基本的数据流类外，Java IO还提供了许多高级的数据流类和接口，如ObjectInputStream和ObjectOutputStream、Reader和Writer等，可以满足更多的读写需求。

### Java中Filter流的作用？
		Java Filter流是一种I/O流，它可以在**读取输入数据或写入输出数据之前或之后对数据进行预处理或过滤**。它的主要作用是在处理文件或流之前或之后对数据进行某种变换或过滤操作，例如，可以将输入的数据进行解密、压缩或转换为其它格式，也可以过滤掉一些无用的数据，以减少对存储空间或带宽的占用。
		在Java程序中，Filter流通常作为其它输入/输出流的装饰器使用，将其它的I/O流包装起来，以增加它们的功能。
		在java.io包中主要由4个可用的filter Stream。两个字节filter stream,两个字符filter stream.分别是FilterInputStream,FilterOutputStream,FilterReader and FilterWriter..这些类是抽象类，不能被实例化的。
### I/O(阻塞、非阻塞，同步、异步)
**同步**：一个任务的完成之前不能做其他操作，必须等待（等于在打电话）
 **异步**：一个任务的完成之前，可以进行其他操作（等于在聊QQ）
 **阻塞**：是相对于CPU来说的， 挂起当前线程，不能做其他操作只能等待 
**非阻塞**：无须挂起当前线程，可以去执行其他操作
### 阻塞IO与非阻塞IO的区别
**阻塞IO**，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞是指用户空间的执行状态。
**非阻塞IO**，指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间执行用户操作，即处于非阻塞IO状态，内核空间会立即返回给用户一个状态值。
阻塞IO：调用线程一直在等待，不能干别的事情。
非阻塞IO：调用线程拿到内核返回的状态值后，IO操作能干就干2，不能就干别的事情。

### BIO和NI0和AIO的区别以及应用场景？
**同步：java自己去处理io。**
**异步：java将io交给操作系统去处理，告诉缓存区大小，处理完成回调。**
**阻塞：使用阻塞IO时，Java调用会一直阻塞到读写完成才返回。**
**非阻塞：使用非阻塞IO时，如果不能立马读写，Jva调用会马上返回，当o事件分发器通知可读写时在进行读写，不断循环直到读写完成。**
**BIO:同步并阻塞**，服务器的实现模式是一个连接一个线程，这样的模式很明显的一个缺陷是：由于客户端连接数与服务器线程数成正比关系，可能造成不必要的线程开销，严重的还将导致服务器内存流出。当然，这种情况可以通过线程池机制改善，但并不能从本质上消除这个弊端。
**NIO**:在JDK1.4以前，Java的IO模型一直是BIO,但从DK1.4开始，JDK引入的新的IO模型NIO,它是同步非阻塞的。而服务器的实现模式是多个请求一个线程，即请求会注册到多路复用器Selector上，多路复用器轮询到连接有IO请求时才启动一个线程处理。
**AIO**:JDK1.7发布了NIO2.0,这就是真正意义上的异步非阻塞，服务器的实现模式为多个有效请求一个线程，客户端的IO请求都是由OS先完成再通知服务器应用去启动线程处理（回调)。
**应用场景**：并发连接数不多时采用BIO,因为它编程和调试都非常简单，但如果涉及到高并发的情况，应选择NIO或AIO,更好的建议是采用成熟的网络通信框Netty。

### 什么是缓冲区？有什么作用

1. 缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性。
2. 对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。

### 什么是Java序列化，反序列化？

1. 序列化就是一种用来处理对象流的机制，将对象的内容进行流化。可以对流化后的对象进行读写操作，可以将流化后的对象传输于网络之间。序列化是为了解决在对象流读写操作时所引发的问题
2. 序列化的实现：将需要被序列化的类实现Serialize接口，没有需要实现的方法，此接口只是为了标注对象可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputStream(对象流)对象，再使用ObjectOutputStream对象的write(Object obj)方法就可以将参数obj的对象写出
## 多线程
### 并行和并发有什么区别？
并发（concurrency）和并行（parallellism）是：
解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群
所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。
### 如何维护线程安全
		**线程安全是指多个线程同时访问共享资源时，不会出现数据竞争、死锁等问题**。以下是一些维护线程安全的方法：

1. **使用同步机制**：使用 synchronized 关键字或者 Lock 对象等同步机制来保护共享资源的访问。
2. **避免共享状态**：尽量避免多个线程同时修改同一个共享状态，可以使用局部变量或者将共享状态封装成对象等方式来实现。
3. **原子操作**：对于需要进行的操作，如果可以保证其在多线程环境下是原子性的，那么就不需要使用同步机制。
4. **读写分离**：对于读多写少的场景，可以将读操作和写操作分别放在不同的线程中执行，避免出现数据竞争的问题。
5. **减少锁的粒度**：锁的粒度越小，能够保护的代码区域就越小，也就越容易出现死锁等问题。因此，应该尽可能地减少锁的粒度。
6. **使用并发容器**：Java 提供了多种并发容器，如 ConcurrentHashMap、CopyOnWriteArrayList 等，这些容器可以在多线程环境下保证数据的正确性和一致性。

总之，维护线程安全需要综合考虑多个因素，包括数据结构、算法、同步机制等，需要根据具体的场景选择合适的方法来实现。
### 线程有哪些状态？
线程的状态：

- NEW 尚未启动
- RUNNABLE 正在执行中
- BLOCKED 阻塞的（被同步锁或者IO锁阻塞）
- WAITING 永久等待状态
- TIMED_WAITING 等待指定的时间重新被唤醒的状态
- TERMINATED 执行完成
### 多线程的实现方式是什么？
		多线程的实现方式有多种，以下是其中的几种：

1. 继承Thread类：通过继承Thread类来创建新的线程对象，重写run()方法并在其中编写线程逻辑。这种方式是最常用的多线程实现方式之一。
2. 实现Runnable接口：通过实现Runnable接口来创建新的线程对象，重写run()方法并在其中编写线程逻辑。与继承Thread类不同的是，Runnable接口没有构造函数，只有一个run()方法。
3. 实现Callable接口：通过实现Callable接口来创建新的线程对象，重写call()方法并在其中编写线程逻辑。Callable接口可以返回一个结果，适用于需要执行耗时操作的情况。
4. 使用Executor框架：使用Java中的Executor框架来管理线程池和执行任务。Executor框架提供了多种线程池类型，可以根据具体需求选择合适的类型。

无论采用哪种方式，多线程编程都需要注意线程安全问题，避免出现竞态条件和死锁等问题。
> 继承Thread类、实现Runnable接口和实现Callable接口都是多线程编程中常用的实现方式，它们的区别如下：
> 1. 继承Thread类：通过继承Thread类来创建新的线程对象，重写run()方法并在其中编写线程逻辑。这种方式是最常用的多线程实现方式之一，因为它可以方便地继承Thread类的属性和方法，例如name、state等。但是，如果在多个线程之间共享同一个对象(如局部变量),可能会出现线程安全问题。
> 2. 实现Runnable接口：通过实现Runnable接口来创建新的线程对象，重写run()方法并在其中编写线程逻辑。与继承Thread类不同的是，Runnable接口没有构造函数，只有一个run()方法。这种方式适用于需要将一个对象作为参数传递给另一个线程的情况，例如使用FutureTask。但是，如果在多个线程之间共享同一个对象(如局部变量),可能会出现线程安全问题。
> 3. 实现Callable接口：通过实现Callable接口来创建新的线程对象，重写call()方法并在其中编写线程逻辑。Callable接口可以返回一个结果，适用于需要执行耗时操作的情况。这种方式适用于需要在另一个线程中调用该线程的结果的情况，例如使用ExecutorService的submit()方法。但是，如果在多个线程之间共享同一个对象(如局部变量),可能会出现线程安全问题。
> 4. 使用Executor框架：使用Java中的Executor框架来管理线程池和执行任务。Executor框架提供了多种线程池类型，可以根据具体需求选择合适的类型。例如，FixedThreadPool适用于固定数量的线程池，CachedThreadPool适用于可缓存的线程池，ScheduledThreadPool适用于定时执行任务的线程池等等。使用Executor框架可以避免手动管理线程的复杂性，但需要注意线程安全问题。

### sleep() 和 wait() 有什么区别？

- 类的不同：sleep() 来自 Thread，wait() 来自 Object。
- 释放锁：sleep() 不释放锁；wait() 释放锁。
- 用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。
### notify()和 notifyAll()有什么区别？
notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。
notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。
### synchronized 和 Lock 有什么区别？
synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
### 线程的 run() 和 start() 有什么区别？
start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。
### ThreadLocal 是什么？有哪些使用场景？
ThreadLocal是Java中的一个线程本地变量，它可以让每个线程都拥有各自独立的值。在多线程编程中，如果多个线程共享同一个变量，那么就可能会出现线程安全问题，需要采用同步控制等方式来保证线程安全。但是有时候，某些变量是每个线程需要独立拥有的，这个时候就可以使用ThreadLocal来实现。
每个Thread对象都有一个ThreadLocalMap类型的成员变量threadLocals，它是一个ThreadLocal的容器，而ThreadLocal则是一个key-value对，key是ThreadLocal对象本身，value是对应的变量值。通过ThreadLocal的set()方法可以将当前线程的对象存入ThreadLocalMap中，而通过get()方法可以获取当前线程的对象。不同线程之间互不干扰，每个线程都可以获取自己的值进行操作。
ThreadLocal主要用来解决线程安全问题，以及实现线程间数据隔离的需求。它常用于实现一些跟线程有关的上下文信息传递，例如，当前会话、当前用户等信息，这些信息可能会涉及到多个模块和类之间的传递和访问，通过ThreadLocal可以轻松实现每个线程拥有各自独立的信息。

### 什么是死锁？如何避免？
死锁是指两个或多个事务在互相等待对方释放资源的情况下，无法继续执行的状态。当发生死锁时，所有等待的事务都会被阻塞，直到有一个事务先释放资源才能继续执行。
避免死锁的方法有以下几种：

1. 避免嵌套事务：尽量减少事务的嵌套层数，避免出现循环等待的情况。
2. 加锁顺序：按照固定的顺序加锁，避免不同事务之间的加锁顺序不一致导致死锁。
3. 超时机制：设置合理的超时时间，如果一个事务等待的时间超过了设定的阈值，就放弃等待并回滚操作。
4. 资源预分配：在事务开始执行之前，提前分配好需要使用的资源，避免在事务执行过程中需要重新分配资源导致死锁。
5. 回滚规则：设置合理的回滚规则，当出现死锁时能够自动回滚并释放资源。

需要注意的是，避免死锁是一个复杂的过程，需要综合考虑多个因素，包括事务的特性、数据库的结构、系统的负载等等。需要根据具体情况进行选择和优化，以达到最佳的性能和可靠性。


## 查找算法
### 基本查找
基本查找也叫做顺序查找
        说明：顺序查找适合于存储结构为数组或者链表。
**基本思想**：顺序查找也称为线形查找，属于无序查找算法。从数据结构线的一端开始，顺序扫描，依次将遍历到的结点与要查找的值相比较，若相等则表示查找成功；若遍历结束仍没有找到相同的，表示查找失败。
示例代码：
```java
public class A01_BasicSearchDemo1 {
    public static void main(String[] args) {
        //基本查找/顺序查找
        //核心：
        //从0索引开始挨个往后查找
        //需求：定义一个方法利用基本查找，查询某个元素是否存在
        //数据如下：{131, 127, 147, 81, 103, 23, 7, 79}
        int[] arr = {131, 127, 147, 81, 103, 23, 7, 79};
        int number = 82;
        System.out.println(basicSearch(arr, number));
    }

    //参数：
    //一：数组
    //二：要查找的元素
    //返回值：
    //元素是否存在
    public static boolean basicSearch(int[] arr, int number){
        //利用基本查找来查找number在数组中是否存在
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] == number){
                return true;
            }
        }
        return false;
    }
}
```
### 二分查找★★★
	也叫做折半查找
说明：元素必须是有序的，从小到大，或者从大到小都是可以的。
如果是无序的，也可以先进行排序。但是排序之后，会改变原有数据的顺序，查找出来元素位置跟原来的元素可能是不一样的，所以排序之后再查找只能判断当前数据是否在容器当中，返回的索引无实际的意义。
　　**基本思想**：也称为是折半查找，属于有序查找算法。用给定值先与中间结点比较。比较完之后有三种情况：

- 相等
说明找到了
- 要查找的数据比中间节点小
说明要查找的数字在中间节点左边
- 要查找的数据比中间节点大
说明要查找的数字在中间节点右边

代码示例：
```java
package com.itheima.search;

public class A02_BinarySearchDemo1 {
    public static void main(String[] args) {
        //二分查找/折半查找
        //核心：
        //每次排除一半的查找范围

        //需求：定义一个方法利用二分查找，查询某个元素在数组中的索引
        //数据如下：{7, 23, 79, 81, 103, 127, 131, 147}

        int[] arr = {7, 23, 79, 81, 103, 127, 131, 147};
        System.out.println(binarySearch(arr, 150));
    }

    public static int binarySearch(int[] arr, int number){
        //1.定义两个变量记录要查找的范围
        int min = 0;
        int max = arr.length - 1;

        //2.利用循环不断的去找要查找的数据
        while(true){
            if(min > max){
                return -1;
            }
            //3.找到min和max的中间位置
            int mid = (min + max) / 2;
            //4.拿着mid指向的元素跟要查找的元素进行比较
            if(arr[mid] > number){
                //4.1 number在mid的左边
                //min不变，max = mid - 1；
                max = mid - 1;
            }else if(arr[mid] < number){
                //4.2 number在mid的右边
                //max不变，min = mid + 1;
                min = mid + 1;
            }else{
                //4.3 number跟mid指向的元素一样
                //找到了
                return mid;
            }

        }
    }
}
```
### 插值查找
在介绍插值查找之前，先考虑一个问题：
	为什么二分查找算法一定要是折半，而不是折四分之一或者折更多呢？
其实就是因为方便，简单，但是如果我能在二分查找的基础上，让中间的mid点，尽可能靠近想要查找的元素，那不就能提高查找的效率了吗？
二分查找中查找点计算如下：
```
mid=(low+high)/2，即mid=low+1/2*(high-low);
```
我们可以将查找的点改进为如下：
```
mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，
```
这样，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。
　　基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。
**细节：**对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。
代码跟二分查找类似，只要修改一下mid的计算方式即可。
### 斐波那契查找
在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。
　　黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。
　　0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。
　　在数学中有一个非常有名的数学规律：斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….
（从第三个数开始，后边每一个数都是前两个数的和）。
然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。
![](assets/20150323100632467#id=mT8MZ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none) 
基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。
斐波那契查找也是在二分查找的基础上进行了优化，优化中间点mid的计算方式即可
代码示例：
```java
public class FeiBoSearchDemo {
    public static int maxSize = 20;

    public static void main(String[] args) {
        int[] arr = {1, 8, 10, 89, 1000, 1234};
        System.out.println(search(arr, 1234));
    }

    public static int[] getFeiBo() {
        int[] arr = new int[maxSize];
        arr[0] = 1;
        arr[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            arr[i] = arr[i - 1] + arr[i - 2];
        }
        return arr;
    }

    public static int search(int[] arr, int key) {
        int low = 0;
        int high = arr.length - 1;
        //表示斐波那契数分割数的下标值
        int index = 0;
        int mid = 0;
        //调用斐波那契数列
        int[] f = getFeiBo();
        //获取斐波那契分割数值的下标
        while (high > (f[index] - 1)) {
            index++;
        }
        //因为f[k]值可能大于a的长度，因此需要使用Arrays工具类，构造一个新法数组，并指向temp[],不足的部分会使用0补齐
        int[] temp = Arrays.copyOf(arr, f[index]);
        //实际需要使用arr数组的最后一个数来填充不足的部分
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = arr[high];
        }
        //使用while循环处理，找到key值
        while (low <= high) {
            mid = low + f[index - 1] - 1;
            if (key < temp[mid]) {//向数组的前面部分进行查找
                high = mid - 1;
                /*
                  对k--进行理解
                  1.全部元素=前面的元素+后面的元素
                  2.f[k]=k[k-1]+f[k-2]
                  因为前面有k-1个元素没所以可以继续分为f[k-1]=f[k-2]+f[k-3]
                  即在f[k-1]的前面继续查找k--
                  即下次循环,mid=f[k-1-1]-1
                 */
                index--;
            } else if (key > temp[mid]) {//向数组的后面的部分进行查找
                low = mid + 1;
                index -= 2;
            } else {//找到了
                //需要确定返回的是哪个下标
                if (mid <= high) {
                    return mid;
                } else {
                    return high;
                }
            }
        }
        return -1;
    }
}

```
### 分块查找
当数据表中的数据元素很多时，可以采用分块查找。
汲取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找
分块查找适用于数据较多，但是数据不会发生变化的情况，如果需要一边添加一边查找，建议使用哈希查找
分块查找的过程：

1. 需要把数据分成N多小块，块与块之间不能有数据重复的交集。
2. 给每一块创建对象单独存储到数组当中
3. 查找数据的时候，先在数组查，当前数据属于哪一块
4. 再到这一块中顺序查找

代码示例：
```java
package com.iflytek.day18;

public class A03_BlockSearchDemo {
    public static void main(String[] args) {
        /*
            分块查找
            核心思想：
                块内无序，块间有序
            实现步骤：
                1.创建数组blockArr存放每一个块对象的信息
                2.先查找blockArr确定要查找的数据属于哪一块
                3.再单独遍历这一块数据即可
        */
        int[] arr = {16, 5, 9, 12,21, 18,
                     32, 23, 37, 26, 45, 34,
                     50, 48, 61, 52, 73, 66};

        //创建三个块的对象
        Block b1 = new Block(21,0,5);
        Block b2 = new Block(45,6,11);
        Block b3 = new Block(73,12,17);

        //定义数组用来管理三个块的对象（索引表）
        Block[] blockArr = {b1,b2,b3};

        //定义一个变量用来记录要查找的元素
        int number = 37;

        //调用方法，传递索引表，数组，要查找的元素
        int index = getIndex(blockArr,arr,number);

        //打印一下
        System.out.println(index);

    }

    //利用分块查找的原理，查询number的索引
    private static int getIndex(Block[] blockArr, int[] arr, int number) {
        //1.确定number是在那一块当中
        int indexBlock = findIndexBlock(blockArr, number);

        if(indexBlock == -1){
            //表示number不在数组当中
            return -1;
        }

        //2.获取这一块的起始索引和结束索引   --- 30
        // Block b1 = new Block(21,0,5);   ----  0
        // Block b2 = new Block(45,6,11);  ----  1
        // Block b3 = new Block(73,12,17); ----  2
        int startIndex = blockArr[indexBlock].getStartIndex();
        int endIndex = blockArr[indexBlock].getEndIndex();

        //3.遍历
        for (int i = startIndex; i <= endIndex; i++) {
            if(arr[i] == number){
                return i;
            }
        }
        return -1;
    }


    //定义一个方法，用来确定number在哪一块当中
    public static int findIndexBlock(Block[] blockArr,int number){ //100

        //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的
        for (int i = 0; i < blockArr.length; i++) {
            if(number <= blockArr[i].getMax()){
                return i;
            }
        }
        return -1;
    }
}

class Block{
    private int max;//最大值
    private int startIndex;//起始索引
    private int endIndex;//结束索引


    public Block() {
    }

    public Block(int max, int startIndex, int endIndex) {
        this.max = max;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
    }

    /**
     * 获取
     * @return max
     */
    public int getMax() {
        return max;
    }

    /**
     * 设置
     * @param max
     */
    public void setMax(int max) {
        this.max = max;
    }

    /**
     * 获取
     * @return startIndex
     */
    public int getStartIndex() {
        return startIndex;
    }

    /**
     * 设置
     * @param startIndex
     */
    public void setStartIndex(int startIndex) {
        this.startIndex = startIndex;
    }

    /**
     * 获取
     * @return endIndex
     */
    public int getEndIndex() {
        return endIndex;
    }

    /**
     * 设置
     * @param endIndex
     */
    public void setEndIndex(int endIndex) {
        this.endIndex = endIndex;
    }

    public String toString() {
        return "Block{max = " + max + ", startIndex = " + startIndex + ", endIndex = " + endIndex + "}";
    }
}
```

## 排序算法
### 冒泡排序★★★
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。
它重复的遍历过要排序的数列，一次比较相邻的两个元素，如果他们的顺序错误就把他们交换过来。
这个算法的名字由来是因为越大的元素会经由交换慢慢"浮"到最后面。
当然，大家可以按照从大到小的方式进行排列。
#### 算法步骤

1. 相邻的元素两两比较，大的放右边，小的放左边
2. 第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推
3. 如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以
#### 动图演示
![](assets/冒泡.gif#id=rqDbf&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
#### 代码示例
```java
package com.iflytek.day18;

public class A01_BubbleDemo {
    public static void main(String[] args) {
        /*
            冒泡排序：
            核心思想：
            1，相邻的元素两两比较，大的放右边，小的放左边。
            2，第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。
            3，如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。
        */


        //1.定义数组
        int[] arr = {2, 4, 5, 3, 1};

        //2.利用冒泡排序将数组中的数据变成 1 2 3 4 5

        //外循环：表示我要执行多少轮。 如果有n个数据，那么执行n - 1 轮
        for (int i = 0; i < arr.length - 1; i++) {
            //内循环：每一轮中我如何比较数据并找到当前的最大值
            //-1：为了防止索引越界
            //-i：提高效率，每一轮执行的次数应该比上一轮少一次。
            for (int j = 0; j < arr.length - 1 - i; j++) {
                //i 依次表示数组中的每一个索引：0 1 2 3 4
                if(arr[j] > arr[j + 1]){
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }

        printArr(arr);

    }

    private static void printArr(int[] arr) {
        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```

### 选择排序
#### 算法步骤

1. 从0索引开始，跟后面的元素一一比较
2. 小的放前面，大的放后面
3. 第一次循环结束后，最小的数据已经确定
4. 第二次循环从1索引开始以此类推
5. 第三轮循环从2索引开始以此类推
6. 第四轮循环从3索引开始以此类推。
#### 动图演示
![](assets/选择排序.gif#id=BuEQL&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)

```java
public class A02_SelectionDemo {
    public static void main(String[] args) {

        /*
            选择排序：
                1，从0索引开始，跟后面的元素一一比较。
                2，小的放前面，大的放后面。
                3，第一次循环结束后，最小的数据已经确定。
                4，第二次循环从1索引开始以此类推。

         */


        //1.定义数组
        int[] arr = {2, 4, 5, 3, 1};


        //2.利用选择排序让数组变成 1 2 3 4 5
       /* //第一轮：
        //从0索引开始，跟后面的元素一一比较。
        for (int i = 0 + 1; i < arr.length; i++) {
            //拿着0索引跟后面的数据进行比较
            if(arr[0] > arr[i]){
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
            }
        }*/

        //最终代码：
        //外循环：几轮
        //i:表示这一轮中，我拿着哪个索引上的数据跟后面的数据进行比较并交换
        for (int i = 0; i < arr.length -1; i++) {
            //内循环：每一轮我要干什么事情？
            //拿着i跟i后面的数据进行比较交换
            for (int j = i + 1; j < arr.length; j++) {
                if(arr[i] > arr[j]){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }


        printArr(arr);


    }
    private static void printArr(int[] arr) {
        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

}

```

### 插入排序
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过创建有序序列和无序序列，然后再遍历无序序列得到里面每一个数字，把每一个数字插入到有序序列中正确的位置。
插入排序在插入的时候，有优化算法，在遍历有序序列找正确位置时，可以采取二分查找。
#### 算法步骤
将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。
遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。
N的范围：0~最大索引
#### 动图演示
![](assets/插入排序.gif#id=c23Wr&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
```java
package com.iflytek.day18;


public class A03_InsertDemo {
    public static void main(String[] args) {
        /*
            插入排序：
                将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。
                遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。
                N的范围：0~最大索引

        */
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

        //1.找到无序的哪一组数组是从哪个索引开始的。  2
        int startIndex = -1;
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] > arr[i + 1]){
                startIndex = i + 1;
                break;
            }
        }

        //2.遍历从startIndex开始到最后一个元素，依次得到无序的哪一组数据中的每一个元素
        for (int i = startIndex; i < arr.length; i++) {
            //问题：如何把遍历到的数据，插入到前面有序的这一组当中

            //记录当前要插入数据的索引
            int j = i;

            while(j > 0 && arr[j] < arr[j - 1]){
                //交换位置
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
                j--;
            }

        }
        printArr(arr);
    }

    private static void printArr(int[] arr) {
        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

}

```


### 快速排序
快速排序是由东尼·霍尔所发展的一种排序算法。
快速排序又是一种分而治之思想在排序算法上的典型应用。
快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！
它是处理大数据最快的排序算法之一了。
#### 算法步骤

1. 从数列中挑出一个元素，一般都是左边第一个数字，称为 "基准数";
2. 创建两个指针，一个从前往后走，一个从后往前走。
3. 先执行后面的指针，找出第一个比基准数小的数字
4. 再执行前面的指针，找出第一个比基准数大的数字
5. 交换两个指针指向的数字
6. 直到两个指针相遇
7. 将基准数跟指针指向位置的数字交换位置，称之为：基准数归位。
8. 第一轮结束之后，基准数左边的数字都是比基准数小的，基准数右边的数字都是比基准数大的。
9. 把基准数左边看做一个序列，把基准数右边看做一个序列，按照刚刚的规则递归排序
#### 动图演示
![](assets/快速排序.gif#id=Z4C4T&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
```java
package com.iflytek.day18;

import java.util.Arrays;

public class A05_QuickSortDemo {
   public static void main(String[] args) {
       System.out.println(Integer.MAX_VALUE);
       System.out.println(Integer.MIN_VALUE);
     /*
       快速排序：
           第一轮：以0索引的数字为基准数，确定基准数在数组中正确的位置。
           比基准数小的全部在左边，比基准数大的全部在右边。
           后面以此类推。
     */

       int[] arr = {1,1, 6, 2, 7, 9, 3, 4, 5, 1,10, 8};


       //int[] arr = new int[1000000];

      /* Random r = new Random();
       for (int i = 0; i < arr.length; i++) {
           arr[i] = r.nextInt();
       }*/


       long start = System.currentTimeMillis();
       quickSort(arr, 0, arr.length - 1);
       long end = System.currentTimeMillis();

       System.out.println(end - start);//149

       System.out.println(Arrays.toString(arr));
       //课堂练习：
       //我们可以利用相同的办法去测试一下，选择排序，冒泡排序以及插入排序运行的效率
       //得到一个结论：快速排序真的非常快。

      /* for (int i = 0; i < arr.length; i++) {
           System.out.print(arr[i] + " ");
       }*/

   }


   /*
    *   参数一：我们要排序的数组
    *   参数二：要排序数组的起始索引
    *   参数三：要排序数组的结束索引
    * */
   public static void quickSort(int[] arr, int i, int j) {
       //定义两个变量记录要查找的范围
       int start = i;
       int end = j;

       if(start > end){
           //递归的出口
           return;
       }



       //记录基准数
       int baseNumber = arr[i];
       //利用循环找到要交换的数字
       while(start != end){
           //利用end，从后往前开始找，找比基准数小的数字
           //int[] arr = {1, 6, 2, 7, 9, 3, 4, 5, 10, 8};
           while(true){
               if(end <= start || arr[end] < baseNumber){
                   break;
               }
               end--;
           }
           System.out.println(end);
           //利用start，从前往后找，找比基准数大的数字
           while(true){
               if(end <= start || arr[start] > baseNumber){
                   break;
               }
               start++;
           }



           //把end和start指向的元素进行交换
           int temp = arr[start];
           arr[start] = arr[end];
           arr[end] = temp;
       }

       //当start和end指向了同一个元素的时候，那么上面的循环就会结束
       //表示已经找到了基准数在数组中应存入的位置
       //基准数归位
       //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换
       int temp = arr[i];
       arr[i] = arr[start];
       arr[start] = temp;

       //确定6左边的范围，重复刚刚所做的事情
       quickSort(arr,i,start - 1);
       //确定6右边的范围，重复刚刚所做的事情
       quickSort(arr,start + 1,j);

   }
}
```

## 设计模式
### 设计模式你知道哪些?
		**创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模块中对象的创建**和对象的使用分离。
（5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式
```latex
记忆口诀：创工原单建抽（创公园，但见愁）
```
**结构型模式（Structural Pattern）**：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像**搭积木**，可以通过简单积木的组合形成复杂的、功能更为强大的结构。
（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
```latex
记忆口诀：结享外组适代装桥（姐想外租，世代装桥）
```
**行为型模式（Behavioral Pattern）**：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的**相互作用**。
（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
```latex
记忆口诀：行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）
```

### 工厂模式
工厂模式是一种非常常用的创建型设计模式，其提供了创建对象的最佳方式。在创建对象时，不会对客户端暴露对象的创建逻辑，而是通过使用共同的接口来创建对象。
**工厂模式的优点**

- 解耦：将对象的创建和使用进行分离
- 可复用：对于创建过程比较复杂且在很多地方都使用到的对象，通过工厂模式可以提高对象创建的代码的复用性。
- 降低成本：由于复杂对象通过工厂进行统一管理，所以只需要修改工厂内部的对象创建过程即可维护对象，从而达到降低成本的目的。

工厂模式可以分为**3**类：

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

**简单工厂模式**
> 简单工厂模式本身是违背开闭原则的，虽可通过反射+配置文件解决，但总体来说不友好。

- 何时使用简单工程模式？
   - 需要创建的对象少
   - 客户端不需要关注对象的创建过程
- 优点
   - 调用者想创建一个对象，只需要知道其名称即可
- 缺点
   - 违背开闭原则，每增加一个对象都需要修改工厂类。
- 总结 简单工厂模式代码简单，虽有多处if分支且违背开闭原则，但扩展性和可读性尚可，这样的代码在大多数情况下并无问题。

**工厂方法模式**
> 简单工厂模式违背了开闭原则，而工厂方法模式则是简单工厂模式的进一步深化，其不像简单工厂模式通过一个工厂来完成所有对象的创建，而是**通过不同的工厂来创建不同的对象**，每个对象有对应的工厂创建。

- 何时使用工厂方法模式？
   - 一个类不需要知道所需对象的类，只需要知道具体类对应的工厂类。
   - 一个类通过其子类来决定创建哪个对象，工厂类只需提供一个创建对象的接口。
   - 将创建对象的任务委托给具体工厂，也可以动态指定由哪个工厂的子类创建。
- 简单工厂模式和工厂方法模式对比 当对象的创建过程比较复杂，需要组合其他类对象做各种初始化操作时，推荐使用**工厂方法模式**，将复杂的创建逻辑拆分到多个工厂类中使得每个工厂类不过于复杂。而使用简单工厂模式则会将所有的创建逻辑都放到一个工厂类，会导致工厂类过于复杂。
- 优点
   - 调用者想创建一个对象，只需要知道其名称即可。
   - 扩展性高，如果增加一个类，只需要扩展一个工厂类。
   - 对调用者屏蔽对象具体实现，调用者只需要关注接口。
- 缺点
   - 当增加一个具体类时，需要增加其对应的工厂类，在一定程度上增加了系统的复杂度。

**抽象工厂模式**
> 抽象工厂模式是对工厂方法模式的进一步深化。在工厂方法模式中，工厂仅可创建一种对象；然而，在抽象工厂模式中，工厂**不仅可创建一种对象，还可创建一组对象**。

- 何时使用抽象工厂模式？
   - 需要一组对象完成某种功能或多组对象完成不同的功能。
   - 系统稳定，不会额外增加对象
- 优点
   - 扩展性高，可通过一组对象实现某个功能
- 缺点
   - 一旦增加就需要修改原有代码，不符合开闭原则，所以尽可能用在不需要修改的场景。
### 单例模式★★★
当一个类的实例可以有且只可以一个的时候就需要用到了。为什么只需要有一个呢？有人说是为了节约内存，但这只是单例模式带来的一个好处。只有一个实例确实减少内存占用，可是我认为这不是使用单例模式的理由。我认为使用单例模式的时机是当实例存在多个会引起程序逻辑错误的时候。比如类似有序的号码生成器这样的东西，怎么可以允许一个应用上存在多个呢？
Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。
一般Singleton模式通常有三种形式:
第一种形式:懒汉式，也是常用的形式。

```java
public class SingletonClass{
    private static SingletonClass instance=null;
    public static　synchronized　SingletonClass getInstance(){
        if(instance==null){
               instance=new SingletonClass();
        }
        return instance;
    }
    private SingletonClass(){
    }
}
```

第二种形式:饿汉式

```java
//对第一行static的一些解释
// java允许我们在一个类里面定义静态类。比如内部类（nested class）。
//把nested class封闭起来的类叫外部类。
//在java中，我们不能用static修饰顶级类（top level class）。
//只有内部类可以为static。
public class Singleton{
    //在自己内部定义自己的一个实例，只供内部调用
    private static final Singleton instance = new Singleton();
    private Singleton(){
        //do something
    }
    //这里提供了一个供外部访问本class的静态方法，可以直接访问
    public static Singleton getInstance(){
        return instance;
    }
}
```
第三种形式: 双重锁的形式。
```java
public class Singleton{
    private static volatile Singleton instance=null;
    private Singleton(){
        //do something
    }
    public static  Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
     }
}
//这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。
//这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，
//假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。
//所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。
```

### 适配器模式
	适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
	这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。
**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
**何时使用：** 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
**如何解决：**继承或依赖（推荐）。
**关键代码：**适配器继承或依赖已有的对象，实现想要的目标接口。
**应用实例：** 
	1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 
	2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 
	3、在 LINUX 上运行 WINDOWS 程序。 
	4、JAVA 中的 jdbc。
**优点：** 
	1、可以让任何两个没有关联的类一起运行。 
	2、提高了类的复用。 
	3、增加了类的透明度。 
	4、灵活性好。
**缺点：** 
	1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 
	2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。
**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
**注意事项：**适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

### 代理模式
#### 定义
**代理模式：对某一个目标对象提供它的代理对象，并且由代理对象控制对原对象的引用。**
例如，我们想访问某个对象A时，不能直接访问，需要由对象A的代理对象A Proxy进行代理。通俗来说，A Proxy我们可以认为是A的助理、中介、对外联络人。
所以，整个类图十分简单，如下所示。
![](assets/v2-add85a7bb2b93d0bd002084715d669dd_b.webp#id=wQ28t&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)
原本客户需要直接调用目标类（委托类），而现在客户需要通过代理类来调用目标类。

#### 作用
在客户类和委托类中增加了代理类这一层，就可以在代理类中增加一些功能，例如起到下面的作用：

- **隔离作用**：可以防止对目标对象的直接访问，实现目标对象与外部的隔离，从而提供安全保障等。例如：在代理中增加权限身份验证。
- **扩展功能**：代理对象可以在目标对象的基础上增加功能。例如：Java切面操作通过建立代理实现。
- **直接替换**：代理对象可以直接替换目标对象的功能，带来全新的实现方式。例如：RPC通过建立代理，直接实现了不存在的接口实现（消费者中只有接口，没有实现类，RPC直接把对实现类的访问转走了）。
#### 静态代理
静态代理就是按照代理模式书写的代码，其**特点是代理类和目标类在代码中是确定的**，因此是静态的。
通过静态代理，我们在目标方法的前后增加了一些操作。
但是，静态代理显然不够灵活。

- 必须要为每个对象创建一个实现了相同接口的代理对象，并且代理对象中的方法也要设置的和原对象一致。因此任何目标对象的变动，代理对象都要变
- 所有代码写死了，不够灵活，不能在运行时改变。

这时，就需要动态代理。他能在代码运行时动态地改变某个对象的代理，并且能为代理对象动态地增加方法、增加行为。

#### 动态代理★★★
 有些时候，我们想要根据运行环境（客户类传来的参数等）动态决定代理类的行为，甚至是动态决定要调用哪个目标类。这就需要动态代理。
动态代理有以下特点:

1. 代理对象，不需要实现接口
2. 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
3. 动态代理也叫做:JDK代理，接口代理

### 观察者模式★★★
	当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。
**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
**主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
**何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。
**如何解决：**使用面向对象技术，可以将这种依赖关系弱化。
**关键代码：**在抽象类里有一个 ArrayList 存放观察者们。
**应用实例：** 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。
**优点：** 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。
**缺点：** 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
**使用场景：**

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

**注意事项：** 
	1、JAVA 中已经有了对观察者模式的支持类。
	 2、避免循环引用。 
	3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。


### 责任链模式
	顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
	在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
**何时使用：**在处理消息的时候以过滤很多道。
**如何解决：**拦截的类都实现统一接口。
**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。
**应用实例：** 1、红楼梦中的"击鼓传花"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，SpringMVC的拦截器，jsp servlet 的 Filter。
**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。
**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。
**使用场景：** 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。
**注意事项：**在 JAVA WEB 中遇到很多应用。

```
 责任链模式在我们生活中有着诸多的应用。比如，在我们玩打扑克的游戏时，某人出牌给他的下家，下家会看看手中的牌，如果要不起上家的牌，则将出牌请求再转发给他的下家，其下家再进行判断，如此反复。一个循环下来，如果其他人都要不起该牌，则最初的出牌者可以打出新的牌。在这个过程中，扑克牌作为一个请求沿着一条链(环)在传递，每一位纸牌的玩家都可以处理该请求。在设计模式中，我们也有一种专门用于处理这种 请求链式传递问题 的模式，即责任链模式 (Chain of Responsibility Pattern)。
```
　此外，采购的分级审批问题也是责任链模式的一个应用典范。我们知道，采购审批往往是分级进行的。也就是说，其常常根据采购金额的不同由不同层次的主管人员来审批。例如，主任可以审批 5 万元以下（不包括 5 万元）的采购单，副董事长可以审批 5 万元至 10 万元（不包括 10 万元）的采购单，董事长可以审批 10 万元至 50 万元（不包括 50 万元）的采购单，50 万元及以上的采购单就需要开董事会讨论决定。此案例如图所示：
![](assets/v2-2ba711eb37a86ab3a1da90ad986e2047_720w.webp#id=uxlOf&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)

## 

